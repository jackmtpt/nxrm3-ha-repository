# Declare variables to be passed into your templates.
namespaces:
  nexusNs:
    enabled: true
    name: "nexusrepo"
  cloudwatchNs:
    enabled: false
    name: amazon-cloudwatch
  externaldnsNs: nexusrepo
serviceAccount:
  enabled: true    #change to true 2024-01-11, enable the service account, by default it's false, it should be true to use the service account
  name: nexus-repository-deployment-sa #This service account in managed by Helm
  annotations:
    # Set annotations for service account. E.g. if deploying to AWS EKS
    # and secrets manager is enabled then this role should have permissions for using secret manager.
    # If using externaldns, role with route53 permissions needed by external-dns
    eks.amazonaws.com/role-arn: arn:aws:iam::497919687739:role/test-dqiu-service-account-role  #dqiu 2024-01-11 uncomment this one to assign the role for serviceaccount
azure:
  enabled: false  #set to true to enable azure specific yamls/snippets
  keyvault:
    enabled: false # set to true to pull license, db and nexus admin password secrets from azure key vault
aws:
  #dqiu 2024-01-11 set to true to enable aws
  enabled: true #set to true to enable aws specific yamls like external dns and fluent bit
  #dqiu 2024-01-11 cluster region is ca-central-1
  clusterRegion: ca-central-1
  #dqiu 2024-01-11 enable the secretemanager for aws
  secretmanager:
    enabled: true # set to true to pull license, db and nexus admin password secrets from aws secret manager
  externaldns:
    #dqiu 2024-01-11 enable external dns 
    enabled: true
    #dqiu 2024-01-11 the domain should be the hosted zone name in Route 53
    domainFilter: coding4fun.ca #your root domain e.g example.com
    #dqiu 2024-01-11 the type is public as the type of the hosted zone in Route 53
    awsZoneType: public # hosted zone to look at (valid values are public, private or no value for both)
  fluentbit:
    enabled: false #set this to true to enable sending of logs to CloudWatch
    fluentBitVersion: 2.28.0
    clusterName: nxrm-nexus
statefulset:
  name: nxrm-statefulset
  serviceName: nxrm-statefulset-service
  replicaCount: 2
  clustered: true
  additionalVolumes:
  additionalVolumeMounts:
  additionalContainers:
  # # Add annotations to statefulset to enhance configurations
  annotations: {}
  podAnnotations: {}
  nodeSelector: {}
  # hostAliases allows the modification of the hosts file inside a container
  hostAliases: []
  # - ip: "192.168.1.10"
  #   hostnames:
  #   - "example.com"
  #   - "www.example.com"

  # Uncomment and modify this to run a command after starting the nexus container.
  postStart:
    command: null   # '["/bin/sh", "-c", "ls"]'
  preStart:
    command: null

  # # Add init containers. e.g. to be used to give specific permissions for nexus-data.
  # # Add your own init containers as needed
  initContainers:
    # chown nexus-data to 'nexus' user and init log directories/files for a new pod
    # otherwise the side car containers will crash a couple of times and backoff whilst waiting
    # for nxrm-app to start and this increases the total start up time.
    - name: chown-nexusdata-owner-to-nexus-and-init-log-dir
      image: busybox:1.33.1
      command: [/bin/sh]
      args:
        - -c
        - >-
          mkdir -p /nexus-data/etc/logback &&
          mkdir -p /nexus-data/log/tasks &&
          mkdir -p /nexus-data/log/audit &&
          touch -a /nexus-data/log/tasks/allTasks.log &&
          touch -a /nexus-data/log/audit/audit.log &&
          touch -a /nexus-data/log/request.log &&
          chown -R '200:200' /nexus-data
      volumeMounts:
        - name: nexus-data
          mountPath: /nexus-data
      resources:
        limits:
          cpu: "0.2"
          memory: "512Mi"
        requests:
          cpu: "0.1"
          memory: "256Mi"
  container:
    image:
      repository: sonatype/nexus3
      tag: 3.64.0
    resources:
      # See help documentation, these are minimum system requirements
      requests:
        cpu: 2
        memory: "8Gi"
      limits:
        cpu: 2
        memory: "8Gi"
    containerPort: 8081
    pullPolicy: IfNotPresent
    terminationGracePeriod: 120
    env:
      nexusDBName: nexus
      nexusDBPort: 5432
      install4jAddVmParams: "-Xms2703m -Xmx2703m"
      jdbcUrlParams: null # Must start with a '?' e.g. "?foo=bar&baz=foo"
  requestLogContainer:
    image:
      repository: busybox
      tag: 1.33.1
    resources:
      limits:
        cpu: "0.2"
        memory: "512Mi"
      requests:
        cpu: "0.1"
        memory: "256Mi"
  auditLogContainer:
    image:
      repository: busybox
      tag: 1.33.1
    resources:
      limits:
        cpu: "0.2"
        memory: "512Mi"
      requests:
        cpu: "0.1"
        memory: "256Mi"
  taskLogContainer:
    image:
      repository: busybox
      tag: 1.33.1
    resources:
      limits:
        cpu: "0.2"
        memory: "512Mi"
      requests:
        cpu: "0.1"
        memory: "256Mi"
  livenessProbe:
    failureThreshold: 6
    initialDelaySeconds: 120
    path: /
    periodSeconds: 60
  readinessProbe:
    failureThreshold: 6
    initialDelaySeconds: 120
    path: /
    periodSeconds: 60
  imagePullSecrets: {}
ingress:
  name: "nexus-ingress"
  #dqiu 2024-01-11 enable the ingress
  enabled: true
  #dqiu 2024-01-11 host should be the 
  host: nexus.coding4fun.ca #host to apply this ingress rule to e.g. example.com. Set it as you wish
  hostPath: /
  dockersubdomain: true # uncomment this if you'd like to create a wildcard rule in your ingress for docker sub domain routing. This will result in the creation of routing rules in your load balancer for sub domains of your host. Thus, you must also set the host
  #dqiu 2024-01-11 need to set to true to populate the rule
  defaultRule: true
  additionalRules: null
  #dqiu 2024-01-11 ingress class name is alb
  ingressClassName: alb # e.g. nginx, alb
#  tls:
#    - secretName: "tlsSecretName1"
#      hosts:
#      - repo.foo1
#      - repo.bar1
#    - secretName: "tlsSecretName2"
#      hosts:
#        - repo.foo2
#        - repo.bar2
  annotations:
#  Note: the annotations below are just a guide; delete or insert more as needed depending on your use case: aws, azure, on prem
#    nginx.ingress.kubernetes.io/ssl-redirect: "false"
    #dqiu 2024-01-11 use internet-facing for test
    alb.ingress.kubernetes.io/scheme: internet-facing # scheme
    alb.ingress.kubernetes.io/tags: Environment=test,Team=Support,Owner=dqiu@sonatype.com
#    alb.ingress.kubernetes.io/subnets: subnet-1,subnet-2 #comma separated list of subnet ids
    # alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}]'
    # alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:us-east-1:0000000000000:certificate/00000000-1111-2222-3333-444444444444  # The AWS Certificate Manager ARN for your HTTPS certificate
#    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:us-east-1:0000000000000:certificate/00000000-1111-2222-3333-444444444444  # Comment out if you don't use docker repositories - The AWS Certificate Manager ARN for your HTTPS certificate
    external-dns.alpha.kubernetes.io/hostname: dockerrepo1.nexus.coding4fun.ca,dockerrepo2.nexus.coding4fun.ca
storageClass:
  enabled: false # For built-in storage class, set storageClass.enabled to false
  name: nexus-storage # For built-in storage class, set storageClass.enabled to false and specify the name of the built-in storage class here e.g. managed-csi for AKS
  #dqiu 2024-01-11 provisoner is ebs
  provisioner: ebs.csi.aws.com # To use your own storage class set storageClass.enabled to true and specify provisioner. E.g. for AKS use managed-csi. For AWS EKS: ebs.csi.aws.com. In case of AWS EKS cluster running version less than 1.23 use 'kubernetes.io/aws-ebs'
  volumeBindingMode: "WaitForFirstConsumer"
  reclaimPolicy: Retain
#  parameters:
#    type: type
#    fsType: "fsType" # e.g. ext4
#    iopsPerGB: "10"
pvc:
  accessModes: ReadWriteOnce
  storage: 2Gi
  volumeClaimTemplate:
    enabled: false
  existingClaim: null

service:  #Nexus Repo NodePort Service
  annotations: {}
  nexus:
    #dqiu 2024-01-11 must enable this one
    enabled: true
    type: NodePort
    protocol: TCP
    port: 80
    targetPort: 8081
secret:
  secretProviderClass: "nexus-secrete-providerclass"
  #dqiu 2024-01-11 provider is aws
  provider: aws # e.g. aws, azure etc
  dbSecret:
    enabled: false # Enable to apply database-secret.yaml which allows you to specify db credentials
  db:
    user: username
    userAlias: nxrm-db-user
    password: password
    passwordAlias: nxrm-db-password
    host: host
    hostAlias: nxrm-db-host
  nexusAdmin:
    name: "admin_nxrm_password"
    alias: "admin-nxrm-password"
  nexusAdminSecret:
    enabled: false # Enable to apply nexus-admin-secret.yaml which allows you to the initial admin password for nexus repository
    adminPassword: yourinitialnexuspassword #You should change this when you login for the first time
  license:
    name: nexus-repo-license.lic
    licenseSecret:
      enabled: false
      file: # Specify the license file name with --set-file license.licenseSecret.file="file_name" helm option
      fileContentsBase64: your_license_file_contents_in_base_64
      mountPath: /var/nexus-repo-license
  azure:
    # a managed identity or service principal that has secrets management access to the key vault
    userAssignedIdentityID: "userAssignedIdentityID"
    tenantId: "azureTenantId"
    keyvaultName: yourazurekeyvault
    useVMManagedIdentity: true
    usePodIdentity: false
  aws:
    license:
      # dqiu 2024-01-11
      arn: arn:aws:secretsmanager:ca-central-1:497919687739:secret:nxrm-license-p9wVVT
    adminpassword:
      arn: arn:aws:secretsmanager:ca-central-1:497919687739:secret:nxrm-admin-init-cred-MkELHq
    rds:
      arn: arn:aws:secretsmanager:ca-central-1:497919687739:secret:nxrm-rds-cred-nexus-VYJnso
nexus:
  # Default the pods UID and GID to match the nexus3 container.
  # Customize or remove these values from the securityContext as appropriate for
  # your deployment environment.
  securityContext:
    runAsUser: 200
  properties:
    override: false
    data: null # specify a list of key and values to override default nexus.properties
  extraLabels: {}
  extraSelectorLabels: {}
  #dqiu 2024-01-11 set to true
  docker:
    enabled: false
    type: NodePort
    protocol: TCP
    registries:
      - host: docker1.nexus.coding4fun.ca
        port: 18079
        secretName: registry-secret
        targetPort: 18079
      - host: docker2.nexus.coding4fun.ca
        port: 18080
        secretName: registry-secret
        targetPort: 18080

# Enable configmap and add arbitrary data in configmap
config:
  enabled: false
  mountPath: /sonatype-nexus-conf
  data: []